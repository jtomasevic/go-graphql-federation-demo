package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.44

import (
	"context"
	"fmt"

	"github.com/jtomasevic/go-graphql-federation-demo/movies/graph"
	"github.com/jtomasevic/go-graphql-federation-demo/movies/graph/model"
	dataloaders "github.com/jtomasevic/go-graphql-federation-demo/movies/services/movies/data_loaders"
)

// Movies is the resolver for the movies field.
func (r *actorResolver) Movies(ctx context.Context, obj *model.Actor) ([]model.Movie, error) {
	fmt.Printf("movie->actorResolver->obj Actor: %s\n", obj.Name)

	// ************************************************************************************
	//// # approach 1 will not solve n+1 issue, because for every Actor we'll have query for getting movies
	//// that is because of loop for _, movieImdbId := range obj.MovieImdbIds which produce such queries.
	// result := []model.Movie{}
	// for _, movieImdbId := range obj.MovieImdbIds {
	// 	movieSubArr, err := dataloaders.GetLoaders(ctx).MoviesByImdbs.Load(movieImdbId)
	// 	if err != nil {
	// 		return nil, err
	// 	}
	// 	result = append(result, fromServiceToGqlMovies(movieSubArr)...)
	// }
	// return result, nil

	// ************************************************************************************
	//// # approach 2
	//// To avoid issue above, and use loder in proper way we'll use LoadAllThunk function.
	//// LoadAllThunk returns a function that when called will block waiting for a Movies.
	//// This method should be used if you want one goroutine to make requests to many different
	//// data loaders without blocking until the thunk is called.

	thunkFn := dataloaders.GetLoaders(ctx).MoviesByImdbs.LoadAllThunk(obj.MovieImdbIds)

	movieArr, err := thunkFn()
	// jt: ^ err is array of errors, and sometimes it is an array of nils, in which case there is no error.
	// So it is not enough just to ask if err != nil, but check every error in array.
	if checkError(err) {
		return nil, err[0]
	}
	result := []model.Movie{}
	for _, movieSubArr := range movieArr {
		result = append(result, fromServiceToGqlMovies(movieSubArr)...)
	}
	return result, nil

	// ************************************************************************************
	//// # approach 3 without data loaders
	// this is implementation without data resolvers, left here so we can learn/compare behaviour.
	// movies, err := r.Services.MovieService.GetMoviesByImdbId(ctx, obj.MovieImdbIds)
	// if err != nil {
	// 	return nil, err
	// }
	// return fromServiceToGqlMovies(movies), nil
}

// Movies is the resolver for the movies field.
func (r *queryResolver) Movies(ctx context.Context) ([]model.Movie, error) {
	movies, err := r.Services.MovieService.GetMovies(ctx)
	if err != nil {
		return nil, err
	}
	return fromServiceToGqlMovies(movies), nil
}

// Actor returns graph.ActorResolver implementation.
func (r *Resolver) Actor() graph.ActorResolver { return &actorResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type actorResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
